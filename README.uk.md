# Опис

Ditsmod є Node.js веб-фреймворком, у його назву закладено **DI** + **TS** + **Mod**, щоб підкреслити важливі його складові: він має **D**ependency **I**njection, написаний на **T**ype**S**cript, та спроектований для хорошої **Mod**ularity (тобто модульності).

Деякі концепції архітектури цього фреймворка взято із [Angular][9].

## Зміст

- [Встановлення](#встановлення)
- [Запуск](#запуск)
- [Мотивація для створення Ditsmod](#мотивація-для-створення-ditsmod)
  - [Огляд ExpressJS та KoaJS](#огляд-expressjs-та-koajs)
  - [Огляд NestJS](#огляд-nestjs)
  - [Огляд Ditsmod](#огляд-ditsmod)

## Встановлення

Мінімальний базовий набір для роботи застосунку Ditsmod має репозиторій [ditsmod-seed][2].
Клонуйте його та встановіть залежності:

```bash
git clone git@github.com:ts-stack/ditsmod-seed.git my-app
cd my-app
npm i
```

Окрім цього, можете проглянути більше прикладів у теці [examples][4].

## Запуск

```bash
npm start
```

## Мотивація для створення Ditsmod

Рідний Node.js веб-сервер надає мінімальну функціональність для прийому HTTP-запитів та відправки HTTP-відповідей. Він не надає систем роутінгу, парсингу тіла запиту, логування, обробки помилок, тестування. І оскільки в реальних застосунках уся перерахована функціональність є базовою, виникає потреба у додатковому веб-фреймворку. З іншого боку, усі перераховані базові фічі є майже у будь-якого Node.js веб-фреймворка, але це ще нічого не говорить про зручність його використання.



### Огляд ExpressJS та KoaJS

Давайте глянемо на зручність використання, наприклад, ExpressJS та KoaJS. Вони використовують дуже мало коду для "Hello, world!", але в реальних застосунках нам треба вирішувати значно складніші завдання, розподіляючи наш код на десятки чи навіть й на сотні файлів. Архітектура даних фреймворків створювались задовго до виходу ES2015, тоді вони вирішували проблему "callback hell" за допомогою створення послідовного ланцюжка викликів так званих middleware, і в кожному із них повинен був викликатись наступний middleware, посилання на який частіше за все передавалось у змінну із назвою `next`.

Таким чином, можна сказати, що головна особливість архітектури цих фреймворків була актуальною до виходу ES2015, коли у JavaScript з'явились `Promise` та класи. Але навіть після виходу ES2015, ES2016, ES2017... майже нічого не змінилось в архітектурі ExpressJS, а у KoaJS 2 додались нові фічі із функціями-генераторами, із функціональністю async/await, із додаванням об'єкту контекста, і все одно стара архітектура із послідовним ланцюжком викликів middleware нікуди не зникла. В плані модульності теж майже нічого не змінилось, окрім хіба що нового способу експорту/імпорту JavaScript модулів, але стара проблема з упорядкуванням структури проекта не зникла.

Як говориться у туторіалі на [developer.mozilla.org][5], ExpressJS дуже мінімалістичний і гнучкий фреймворк, але це часто й ускладнює створення правильної структури проекту:

> While Express itself is fairly minimalist, developers have created compatible middleware packages to address almost any web development problem. There are libraries to work with cookies, sessions, user logins, URL parameters, POST data, security headers, and many more. You can find a list of middleware packages maintained by the Express team at Express Middleware (along with a list of some popular 3rd party packages).
>
> This flexibility is a double edged sword. There are middleware packages to address almost any problem or requirement, but working out the right packages to use can sometimes be a challenge. There is also no "right way" to structure an application, and many examples you might find on the Internet are not optimal, or only show a small part of what you need to do in order to develop a web application.

Судячи із постів на різних блогах, ExpressJS та KoaJS використовують майже завжди на малих проектах, а також для мікросервісів, де якраз кожен "мікросервіс" сам по собі являється малим застосунком.

### Огляд NestJS

TypeScript вніс у світ JavaScript, можна сказати без перебільшення, революційні можливості для зручності написання коду в IDE, можливості для дуже суттєвого зменшення кількості помилок, а отже - проекти написані на TypeScript можна робити значно більшими. А якщо ще й код певного веб-фреймворку написано на TypeScript, це дозволяє нам в IDE мати завжди актуальний API цих фреймворків.

На даний момент є досить популярний веб-фреймворк написаний на TypeScript - це NestJS. Перший стабільний його реліз був в кінці 2017 року, тобто вже після виходу ES2015, ES2016, ES2017. Його автор дуже активно розвиває своє дітище, а тижнева кількість скачувань із npmjs.com складає вже майже 300 тис. і продовжує стабільно рости.

Видно що автор NestJS дуже старанно намагається додати до цього фреймворка усе саме сучасне і прогресивне. Справді, NestJS:
- має власний CLI
- має велику кількість декораторів для різних потреб
- впроваджено багато фіч, дуже схожих на Angular фічі: Dependency Injection, провайдери, модулі, pipes, guards, interceptors, lifecycle events...
- має підтримку TypeORM
- має підтримку OpenAPI
- має підтримку GraphQL
- має підтримку Websockets
- має рекомендації для використання мікросервісів
- ...

Так чому ж, знаючи про NestJS, виникла потреба у створенні Ditsmod? Головною причиною була моя суб'єктивна оцінка NestJS, мені здалось що можна написати веб-фреймворк із простішим API але, разом із тим, зробити його більш потужнішим як в плані продуктивності, так і в плані масштабованості.

### Огляд Ditsmod

По великому рахунку, головною особливістю Ditsmod є інтеграція рідного Node.js веб-сервера з модулем [Dependency Injection][1].

Що це дає:
- Зручний механізм [указання та вирішення залежностей][8] між різними класами застосунку. Зокрема, завдяки цьому механізму, дуже суттєво спрощується тестування.
- Можливість будувати хорошу модульність структури всього застосунку, а отже і хорошу масштабованість. Окрім цього, даний DI підтримує ієрархію, а це означає, що ви можете оголошувати сервіси з областю видимості: або на рівні усього застосунку, або на рівні конкретного модуля, або на рівні конкретного контролера.
   1. Якщо сервіс оголошено на рівні застосунку, то сінглтон цього сервісу буде створено один єдиний раз - при старті застосунку. Наприклад, таким сервісом може бути сервіс MySql.
   2. Сервіс на рівні модуля може створюватись декілька разів, якщо його буде імпортовано в декілька різних модулів, і в кожному із цих модулів буде свій окремий сінглтон. Наприклад, таким сервісом може бути сервіс надання конфігурації.
   3. Сервіс на рівні конкретного контролера буде створюватись при кожному створенні інстансу цього контролера, тобто при кожному запиті (з відповідним маршрутом). Наприклад, таким сервісом може бути парсер тіла запиту.
- Не зважаючи на додатковий прошарок у ядрі Ditsmod для підтримки модульності застосунку, тести "Hello, World!" показують, що він працює навіть трохи швидше за такий легкий фреймворк як KoaJS:

![req-per-sec-frameworks.png](https://raw.githubusercontent.com/ts-stack/vs-webframework/master/req-per-sec-frameworks.png)

Код із даними бенчмарками ви можете знайти у [цьому репозиторії][7].

## Ознайомлення з Ditsmod

Після [встановлення Ditsmod seed](#встановлення), перше, що необхідно знати: весь код застосунку знаходиться у теці `src`, він компілюється за допомогою TypeScript-утиліти `tsc`, після компіляції він попадає у теку `dist`, і далі вже у вигляді JavaScript-коду його можна виконувати у Node.js.

Давайте розглянемо файл `src/main.ts`:

```ts
import 'reflect-metadata';
import { AppFactory } from '@ts-stack/ditsmod';

import { AppModule } from './app/app.module';

new AppFactory()
  .bootstrap(AppModule)
  .then(({ server, log }) => {
    server.on('error', (err) => log.error(err));
  })
  .catch(({ err, log }) => {
    log.fatal(err);
  });
```

Після компіляції, він перетворюється на `dist/main.js` та стає вхідною точкою для запуску застосунку, і саме тому ви будете його вказувати у якості аргументу для Node.js:

```bash
node dist/main.js
```

Слід звернути увагу на `import 'reflect-metadata'` у першому рядку файла. Цей модуль необхідний для роботи Ditsmod, але його достатньо указувати єдиний раз у вхідному файлі для Node.js.

Бажано запам'ятати дане правило на майбутнє, і застосовувати його також для написання тестів, оскільки в такому разі вхідним файлом вже буде файл тесту, а не `dist/main.js`. Наприклад, якщо ви будете використовувати [jest][10] у якості фреймворку для тестів, а файл `path/to/test-file.js` міститиме скомпільований тест, то щоб запустити його ось так:

```bash
jest path/to/test-file.js
```

у файлі `path/to/test-file.js` повинен бути імпорт `reflect-metadata`.

Проглядаючи далі файл `src/main.ts`, ми бачимо, що створюється інстанс класу `AppFactory`, а у якості аргументу для методу `bootstrap()` передається `AppModule`. Тут `AppModule` є кореневим модулем, до якого вже підв'язуються інші модулі застосунку.

## API

### AppFactory

```ts
bootstrap(appModule: ModuleType): Promise<{ server: Server; log: Logger }>;
```

Під час роботи методу `bootstrap()`:
1. відбувається читання конфігурації із метаданих, закріплених за різними декораторами затосунку (`@RootModule()`, `@Module()`, `@Controller()`, `@Route()` і т.д.);
2. відбувається валідація та злиття даної конфігурації із початковими (default) значеннями застосунку;
3. враховуючи модульність та ієрархію вказану у конфігурації, готуються інжектори з різними наборами сервісів;

### Зауваження

- Сервіс, оголошений на рівні застосунку, не повинен запитувати у своїх конструкторах сервіс,
оголошений на нижчому рівні (модуля чи запиту), оскільки він створюються один раз - при ініціалізації застосунку. Аналогічно сервіс, оголошений на рівні модуля не повинен запитувати у своєму конструкторі сервіс, оглошений на рівні запиту.
- Щоб оголосити сервіси у глобальному просторі на будь-якому рівні (на рівні застосунку, модуля чи запиту),
спочатку потрібно:
  - або оголосити сервіс у кореневому модулі на потрібному рівні
  - або імпортувати модуль із потрібним сервісом у кореневий модуль
Після чого необхідно еспортувати ці сервіси, або модулі із цими сервісами.


[1]: https://github.com/ts-stack/di
[2]: https://github.com/ts-stack/ditsmod-seed
[3]: https://github.com/ts-stack/ditsmod
[4]: https://github.com/ts-stack/ditsmod/tree/master/examples
[5]: https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/Introduction#Introducing_Express
[6]: https://github.com/nestjsx/nest-router
[7]: https://github.com/ts-stack/vs-webframework
[8]: https://uk.wikipedia.org/wiki/%D0%92%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B4%D0%B6%D0%B5%D0%BD%D0%BD%D1%8F_%D0%B7%D0%B0%D0%BB%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9
[9]: https://github.com/angular/angular
[10]: https://jestjs.io/en/