# @ts-stack/mod

`@ts-stack/mod` написаний на TypeScript, він є Node.js веб-фреймворком, в назві якого слово `mod` означає хорошу модульність.
Ця модульність забезпечується, у великій мірі, завдяки системі [Dependency Injection][1].

## Зміст

- [Встановлення](#встановлення)

## Встановлення

Мінімальний базовий набір для роботи застосунку `@ts-stack/mod` має репозиторій [mod-seed][2].
Клонуйте його та встановіть залежності:

```bash
git clone git@github.com:ts-stack/mod-seed.git my-app
cd my-app
npm i
```

Окрім цього, можете проглянути більше прикладів у теці [examples][4].

## Запуск

```bash
npm start
```

## Порівняння `@ts-stack/mod` з іншими веб-фреймворками

Рідний Node.js веб-сервер надає мінімальну функціональність для прийому HTTP-запитів та відправки HTTP-відповідей. Він не надає систем роутінгу, парсингу тіла запиту, логування, обробки помилок, тестування. І оскільки в реальних застосунках уся перерахована функціональність є базовою, виникає потреба у додатковому веб-фреймворку. З іншого боку, сама наявність цієї базової функціональності ще нічого не говорить про зручність використання певного фреймворку.

Усі перераховані базові фічі є майже у будь-якого Node.js веб-фреймворка, чому б просто не використовувати найпопулярніші із них?

### Огляд ExpressJS та KoaJS

Давайте глянемо на зручність використання, наприклад, ExpressJS та KoaJS. Вони використовують дуже мало коду для "Hello, world!", але в реальних застосунках нам треба вирішувати значно складніші завдання, розподіляючи наш код при цьому на десятки чи навіть й на сотні файлів. Архітектура даних фреймворків створювались задовго до виходу ES2015, тоді вони вирішували проблему "callback hell" за допомогою створення послідовного ланцюжка викликів так званих middleware, і в кожному із них повинна була викликатись функція `next()`.

Після виходу ES2015 майже нічого не змінилось в архітектурі ExpressJS, а у KoaJS 2 додались нові фічі із функціями-генераторами, із функціональністю async/await, із додаванням об'єкту контекста, але стара архітектура із послідовним ланцюжком викликів middleware нікуди не зникла. В плані модульності теж майже нічого не змінилось, окрім хіба що нового способу експорту/імпорту JavaScript модулів, але стара проблема з упорядкуванням структури проекта не зникла.

Як говориться у туторіалі на [developer.mozilla.org][5], ExpressJS дуже мінімалістичний і гнучкий фреймворк, але це часто й ускладнює створення правильної структури проекту:

> While Express itself is fairly minimalist, developers have created compatible middleware packages to address almost any web development problem. There are libraries to work with cookies, sessions, user logins, URL parameters, POST data, security headers, and many more. You can find a list of middleware packages maintained by the Express team at Express Middleware (along with a list of some popular 3rd party packages).
>
> This flexibility is a double edged sword. There are middleware packages to address almost any problem or requirement, but working out the right packages to use can sometimes be a challenge. There is also no "right way" to structure an application, and many examples you might find on the Internet are not optimal, or only show a small part of what you need to do in order to develop a web application.

Судячи із постів на різних блогах, ExpressJS та KoaJS використовують майже завжди на малих проектах, а також для мікросервісів, де якраз кожен "мікросервіс" сам по собі являється малим застосунком.

### Огляд NestJS

TypeScript вніс у світ JavaScript, можна сказати без перебільшення, революційні можливості для зручності написання коду в IDE, можливості для дуже суттєвого зменшення кількості помилок, а отже - проекти написані на TypeScript можна робити значно більшими. А якщо ще й код певного веб-фреймворку написано на TypeScript, це дозволяє нам мати завжди актуальний API цих фреймворків.

На даний момент є досить популярний веб-фреймворк написаний на TypeScript - це NestJS. Стабільний його реліз був в кінці 2017 року, тобто вже після виходу ES2015, ES2016, ES2017. NestJS без сумнівно є одним із самих прогресивних веб-фреймворків в плані впровадження сучасних можливостей TypeScript/JavaScript. Його автор дуже активно розвиває своє дітище, а тижнева кількість скачувань із npmjs.com складає вже майже 300 тис. і продовжує стабільно рости.

Видно що автор NestJS дуже старанно намагається додати до цього фреймворка усе саме сучасне і прогресивне. Справді, NestJS:
- має власний CLI
- має велику кількість декораторів для різних потреб
- впроваджено багато фіч, дуже схожих на Angular фічі: Dependency Injection, провайдери, модулі, pipes, guards, interceptors, lifecycle events...
- має підтримку TypeORM
- має підтримку OpenAPI
- має підтримку GraphQL
- має підтримку Websockets
- має рекомендації для використання мікросервісів
- ...

Так чому ж, знаючи про NestJS, виникла потреба у створенні `@ts-stack/mod`?

1. Схоже, що NestJS не має такої архітектури, щоб можна було мати підтримку усієї вищенаведеної функціональністі, і при цьому не переобтяжувати ядро цього фреймворка. Навіть без додаткових модулів, голий NestJS v7.3.2 (на момент написання цього тексту) помітно повільніший за Fastify, KoaJS, Restify, ExpressJS... Можна сказати, що він є одним із найповільніших серед NodeJS-фреймворків.
2. NestJS не має рідної підтримки для вкладених роутів, є лише [сторонній відповідний модуль][6]. Що є дуже суттєвим, а інколи і критичним недоліком для великих проектів. Це також додатково вказує на слабкість архітектури цього фреймворку.
3. Велика кількість інших дрібніших недоліків, мабуть спричинених поспішністю автора NestJS впроваджувати нову функціональність без належної оптимізації вже наявної функціональності. Таке суб'єктивне, але чітке враження у мене склалось після знайомства з цим фреймворком.

### Огляд `@ts-stack/mod`

По великому рахунку, головною особливістю `@ts-stack/mod` є інтеграція рідного Node.js веб-сервера з модулем [Dependency Injection][1] (скорочено - DI).

Що це дає:
- Зручний механізм указання та вирішення залежностей між різними класами застосунку. Зокрема, завдяки цьому механізму, дуже суттєво спрощується тестування.
- Хорошу модульність структури всього застосунку, а отже і хорошу масштабованість. Окрім цього, даний DI підтримує ієрархію, а це означає, що ви можете оголошувати сервіси з областю видимості: або на рівні усього застосунку, або на рівні конкретного модуля, або на рівні конкретного контролера.
   1. Якщо сервіс оголошено на рівні застосунку, то сінглтон цього сервісу буде створено один єдиний раз - при старті. Наприклад, таким сервісом може бути сервіс MySql.
   2. Сервіс на рівні модуля може створюватись декілька разів, якщо його буде імпортовано в декілька різних модулів, і в кожному із цих модулів буде свій окремий сінглтон. Наприклад, таким сервісом може бути сервіс надання конфігурації.
   3. Сервіс на рівні конкретного контролера буде створюватись при кожному створенні інстансу цього контролера, тобто при кожному запиті (з відповідним маршрутом). Наприклад, таким сервісом може бути парсер тіла запиту.
- Не зважаючи на додатковий прошарок у ядрі `@ts-stack/mod` для підтримки модульності застосунку, тести "Hello, World!" показують, що він працює майже так само швидко як і Fastify чи KoaJS, помітно обганяє Restify, і майже удвічі швидший за ExpressJS та NestJS:

![req-per-sec-frameworks.png](https://raw.githubusercontent.com/ts-stack/vs-webframework/master/req-per-sec-frameworks.png)

Код із цими тестами ви можете знайти у [цьому репозиторії][7].

Для середніх та великих проектів це дає дуже суттєву перевагу як в плані масштабованості, так і в плані зручності використання.

### Зауваження

- Сервіс, оголошений на рівні застосунку, не повинен запитувати у своїх конструкторах сервіс,
оголошений на нижчому рівні (модуля чи запиту), оскільки він створюються один раз - при ініціалізації застосунку. Аналогічно сервіс, оголошений на рівні модуля не повинен запитувати у своєму конструкторі сервіс, оглошений на рівні запиту.
- Щоб оголосити сервіси у глобальному просторі на будь-якому рівні (на рівні застосунку, модуля чи запиту),
спочатку потрібно:
  - або оголосити сервіс у кореневому модулі на потрібному рівні
  - або імпортувати модуль із потрібним сервісом у кореневий модуль
Після чого необхідно еспортувати ці сервіси, або модулі із цими сервісами.


[1]: https://github.com/ts-stack/di
[2]: https://github.com/ts-stack/mod-seed
[3]: https://github.com/ts-stack/mod
[4]: https://github.com/ts-stack/mod/tree/master/examples
[5]: https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/Introduction#Introducing_Express
[6]: https://github.com/nestjsx/nest-router
[7]: https://github.com/ts-stack/vs-webframework
