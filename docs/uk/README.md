# Що таке Ditsmod

Ditsmod є Node.js веб-фреймворком, його назва складається із **DI** + **TS** + **Mod**, щоб підкреслити важливі складові: він має **D**ependency **I**njection, написаний на **T**ype**S**cript, та спроектований для хорошої **Mod**ularity (тобто модульності).

Головні особливості Ditsmod:
- Зручний механізм [указання та вирішення залежностей][8] між різними класами застосунку: ви в конструкторі класу указуєте інстанси яких класів вам потрібні, а DI бере на себе непросту задачу "де їх взяти".
- Можливість легко підмінювати by default класи Ditsmod своїми власними класами. Наприклад, швидше за все, ви захочете підмінити клас логера на ваш власний клас, оскільки by default логер нічого не записує ні в консоль, ні у файл.
- Можливість легко підмінювати класи вашого застосунку тестовими класами (mocks, stubs), не змінюючи при цьому код вашого застосунку. Це дуже суттєво спрощує тестування.
- Ditsmod спроектований, щоб забезпечувати хорошу модульність всього застосунку, а отже і хорошу масштабованість. Його DI підтримує ієрархію, а це означає, що ви можете оголошувати [одинаків][12]: або на рівні усього застосунку, або на рівні конкретного модуля, або на рівні HTTP-запиту.
   1. Якщо одинака оголошено на рівні застосунку, то інстанс відповідного класу буде створено один єдиний раз - при старті застосунку. Наприклад, таким одинаком може бути інстанс класу для роботи з MySQL.
   2. Одинаки, оголошені на рівні модуля, є саме одинаками, але лише в тому модулі, що їх імпортує. Якщо клас цього одинака імпортують декілька модулів, то відповідно - буде створено по одному одинаку для кожного модуля. Наприклад, це може бути інстанс класу для надання конфігурації.
   3. Одинак на рівні запиту буде створюватись відповідно - при кожному запиті. Наприклад, це може бути парсер тіла запиту.

Ті, хто знайомий з [Angular][9], помітить, що деякі концепції архітектури цього фреймворка дуже схожі на Angular концепції. Це справді так, більше того - сам [DI][11] фактично витягнутий з Angular v4.4.7. та інтегрований в Ditsmod з мінімальними допрацюваннями.

## Зміст

- [Встановлення](#встановлення)
- [Запуск](#запуск)
- [Ознайомлення з Ditsmod](#ознайомлення-з-ditsmod)

## Встановлення

Мінімальний базовий набір для роботи застосунку Ditsmod має репозиторій [ditsmod-seed][2].
Клонуйте його та встановіть залежності:

```bash
git clone git@github.com:ts-stack/ditsmod-seed.git my-app
cd my-app
npm i
```

Окрім цього, можете проглянути більше прикладів у теці [examples][4].

## Запуск

```bash
npm start
```

Перевірити роботу сервера можна за допомогою `curl`:

```bash
curl -isS localhost:8080
```

## Ознайомлення з Ditsmod

Після [встановлення Ditsmod seed](#встановлення), перше, що необхідно знати: весь код застосунку знаходиться у теці `src`, він компілюється за допомогою TypeScript-утиліти `tsc`, після компіляції він попадає у теку `dist`, і далі вже у вигляді JavaScript-коду його можна виконувати у Node.js.

Давайте розглянемо файл `src/main.ts`:

```ts
import 'reflect-metadata';
import { AppFactory } from '@ts-stack/ditsmod';

import { AppModule } from './app/app.module';

new AppFactory()
  .bootstrap(AppModule)
  .then(({ server, log }) => {
    server.on('error', (err) => log.error(err));
  })
  .catch(({ err, log }) => {
    log.fatal(err);
    throw err;
  });
```

Після компіляції, він перетворюється на `dist/main.js` та стає вхідною точкою для запуску застосунку, і саме тому ви будете його вказувати у якості аргументу для Node.js:

```bash
node dist/main.js
```

Слід звернути увагу на `import 'reflect-metadata'` у першому рядку файла. Цей модуль необхідний для роботи Ditsmod, але його достатньо указувати єдиний раз у вхідному файлі для Node.js.

Бажано запам'ятати дане правило на майбутнє, і застосовувати його також для написання тестів, оскільки в такому разі вхідним файлом вже буде файл тесту, а не `dist/main.js`. Наприклад, якщо ви будете використовувати [jest][10] у якості фреймворку для тестів, а файл `path/to/test-file.js` міститиме скомпільований тест, то щоб запустити його ось так:

```bash
jest path/to/test-file.js
```

у файлі `path/to/test-file.js` повинен бути імпорт `reflect-metadata`.

Проглядаючи далі файл `src/main.ts`, ми бачимо, що створюється інстанс класу `AppFactory`, а у якості аргументу для методу `bootstrap()` передається `AppModule`. Тут `AppModule` є кореневим модулем, до якого вже підв'язуються інші модулі застосунку.

## API

### Клас AppFactory

```ts
bootstrap(appModule: ModuleType): Promise<{ server: Server; log: Logger }>;
```

Під час роботи методу `bootstrap()`:
1. відбувається читання конфігурації із метаданих, закріплених за різними декораторами затосунку (`@RootModule()`, `@Module()`, `@Controller()`, `@Route()` і т.д.);
2. відбувається валідація та злиття даної конфігурації із початковими (default) значеннями застосунку;
3. враховуючи модульність та ієрархію вказану у конфігурації, готуються інжектори з різними наборами сервісів;

### Зауваження

- Сервіс, оголошений на рівні застосунку, не повинен запитувати у своїх конструкторах сервіс,
оголошений на нижчому рівні (модуля чи запиту), оскільки він створюються один раз - при ініціалізації застосунку. Аналогічно сервіс, оголошений на рівні модуля не повинен запитувати у своєму конструкторі сервіс, оглошений на рівні запиту.
- Щоб оголосити сервіси у глобальному просторі на будь-якому рівні (на рівні застосунку, модуля чи запиту),
спочатку потрібно:
  - або оголосити сервіс у кореневому модулі на потрібному рівні
  - або імпортувати модуль із потрібним сервісом у кореневий модуль
Після чого необхідно еспортувати ці сервіси, або модулі із цими сервісами.


[1]: https://github.com/ts-stack/di
[2]: https://github.com/ts-stack/ditsmod-seed
[3]: https://github.com/ts-stack/ditsmod
[4]: https://github.com/ts-stack/ditsmod/tree/master/examples
[6]: https://github.com/nestjsx/nest-router
[8]: https://uk.wikipedia.org/wiki/%D0%92%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B4%D0%B6%D0%B5%D0%BD%D0%BD%D1%8F_%D0%B7%D0%B0%D0%BB%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9
[9]: https://github.com/angular/angular
[10]: https://jestjs.io/en/
[11]: https://github.com/ts-stack/di
[12]: https://uk.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%B0%D0%BA_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F) "Singleton"
