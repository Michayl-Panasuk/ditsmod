## Зміст

- [Огляд ExpressJS та KoaJS](#огляд-expressjs-та-koajs)
- [Огляд NestJS](#огляд-nestjs)
- [Огляд Ditsmod](#огляд-ditsmod)

## Мотивація для створення Ditsmod

Рідний Node.js веб-сервер надає мінімальну функціональність для прийому HTTP-запитів та відправки HTTP-відповідей. Він не надає систем роутінгу, парсингу тіла запиту, логування, обробки помилок, тестування. І оскільки в реальних застосунках уся перерахована функціональність є базовою, виникає потреба у додатковому веб-фреймворку. З іншого боку, уся перерахована базова функціональність є майже у будь-якого Node.js веб-фреймворка, але це ще нічого не говорить про зручність його використання.

### Огляд ExpressJS та KoaJS

Давайте глянемо на зручність використання, наприклад, ExpressJS та KoaJS. Вони використовують дуже мало коду для "Hello, world!", але в реальних застосунках нам треба вирішувати значно складніші завдання, розподіляючи наш код на десятки чи навіть й на сотні файлів. Архітектура даних фреймворків формувалась задовго до виходу ES2015, тоді вони вирішували проблему "callback hell" за допомогою створення послідовного ланцюжка викликів так званих middleware, і в кожному із них повинен був викликатись наступний middleware, посилання на який частіше за все передавалось у змінну із назвою `next`.

Таким чином, можна сказати, що головна особливість архітектури цих фреймворків була актуальною до виходу ES2015, коли у JavaScript з'явились `Promise` та класи. Хоча виходили в реліз ES2015, ES2016, ES2017... майже нічого не змінилось в архітектурі ExpressJS, а у KoaJS 2 додались нові фічі із функціями-генераторами, із функціональністю async/await, із додаванням об'єкту контекста. Але все одно стара архітектура із послідовним ланцюжком викликів middleware нікуди не зникла. В плані модульності теж майже нічого не змінилось, окрім хіба що нового способу експорту/імпорту JavaScript модулів, але стара проблема з упорядкуванням структури проекта не зникла.

Як говориться у туторіалі на [developer.mozilla.org][5], ExpressJS дуже мінімалістичний і гнучкий фреймворк, але це часто й ускладнює створення правильної структури проекту:

> While Express itself is fairly minimalist, developers have created compatible middleware packages to address almost any web development problem. There are libraries to work with cookies, sessions, user logins, URL parameters, POST data, security headers, and many more. You can find a list of middleware packages maintained by the Express team at Express Middleware (along with a list of some popular 3rd party packages).
>
> This flexibility is a double edged sword. There are middleware packages to address almost any problem or requirement, but working out the right packages to use can sometimes be a challenge. There is also no "right way" to structure an application, and many examples you might find on the Internet are not optimal, or only show a small part of what you need to do in order to develop a web application.

Судячи із постів на різних блогах, ExpressJS та KoaJS використовують майже завжди на малих проектах, а також для мікросервісів, де якраз кожен "мікросервіс" сам по собі являється малим застосунком.

### Огляд NestJS

TypeScript вніс у світ JavaScript, можна сказати без перебільшення, революційні можливості для зручності написання коду в IDE, можливості для дуже суттєвого зменшення кількості помилок, а отже - проекти написані на TypeScript можна робити значно більшими.

На даний момент є досить популярний веб-фреймворк написаний на TypeScript - це NestJS. Перший стабільний його реліз був в кінці 2017 року, тобто вже після виходу ES2015, ES2016, ES2017. Його автор дуже активно розвиває своє дітище, а тижнева кількість скачувань із npmjs.com складає вже майже 300 тис. і продовжує стабільно рости.

Видно що автор NestJS дуже старанно намагається додати до цього фреймворка усе саме сучасне і прогресивне. Справді, NestJS:
- має власний CLI
- має велику кількість декораторів для різних потреб
- впроваджено багато фіч, дуже схожих на Angular фічі: Dependency Injection, провайдери, модулі, pipes, guards, interceptors, lifecycle events...
- має підтримку TypeORM
- має підтримку OpenAPI
- має підтримку GraphQL
- має підтримку Websockets
- має рекомендації для використання мікросервісів
- ...

Так чому ж, знаючи про NestJS, виникла потреба у створенні Ditsmod? Головною причиною була моя суб'єктивна оцінка NestJS, мені здалось що можна написати веб-фреймворк із простішим API але, разом із тим, зробити його більш потужнішим як в плані продуктивності, так і в плані масштабованості.

### Огляд Ditsmod

По великому рахунку, головною особливістю Ditsmod є інтеграція рідного Node.js веб-сервера з модулем [Dependency Injection][1].

Що це дає:
- Зручний механізм [указання та вирішення залежностей][8] між різними класами застосунку: ви в конструкторі класу указуєте інстанси яких класів вам потрібні, а DI бере на себе непросту задачу "де їх взяти".
- Можливість легко підмінювати by default класи Ditsmod своїми власними класами. Наприклад, швидше за все, ви захочете підмінити клас логера на ваш власний клас, оскільки by default логер нічого не записує ні в консоль, ні у файл.
- Можливість легко підмінювати класи вашого застосунку тестовими класами (mocks, stubs), не змінюючи при цьому код вашого застосунку. Це дуже суттєво спрощує тестування.
- Ditsmod спроектований, щоб забезпечувати хорошу модульність всього застосунку, а отже і хорошу масштабованість. Його DI підтримує ієрархію, а це означає, що ви можете оголошувати [одинаків][12]: або на рівні усього застосунку, або на рівні конкретного модуля, або на рівні HTTP-запиту.
   1. Якщо одинака оголошено на рівні застосунку, то інстанс відповідного класу буде створено один єдиний раз - при старті застосунку. Наприклад, таким одинаком може бути інстанс класу для роботи з MySQL.
   2. Одинаки, оголошені на рівні модуля, є саме одинаками, але лише в тому модулі, що їх імпортує. Якщо клас цього одинака імпортують декілька модулів, то відповідно - буде створено по одному одинаку для кожного модуля. Наприклад, це може бути інстанс класу для надання конфігурації.
   3. Одинак на рівні запиту буде створюватись відповідно - при кожному запиті. Наприклад, це може бути парсер тіла запиту.

Ті, хто знайомий з [Angular][9], помітить, що деякі концепції архітектури цього фреймворка дуже схожі на Angular концепції. Це справді так, більше того - сам [DI][11] фактично витягнутий з Angular v4.4.7. та інтегрований в Ditsmod з мінімальними допрацюваннями.
- Не зважаючи на додатковий прошарок у ядрі Ditsmod для підтримки модульності застосунку, тести "Hello, World!" показують, що він працює навіть трохи швидше за такий легкий фреймворк як KoaJS:

![req-per-sec-frameworks.png](https://raw.githubusercontent.com/ts-stack/vs-webframework/master/req-per-sec-frameworks.png)

Код із даними бенчмарками ви можете знайти у [цьому репозиторії][7].



[1]: https://github.com/ts-stack/di
[5]: https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/Introduction#Introducing_Express
[7]: https://github.com/ts-stack/vs-webframework
[8]: https://uk.wikipedia.org/wiki/%D0%92%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B4%D0%B6%D0%B5%D0%BD%D0%BD%D1%8F_%D0%B7%D0%B0%D0%BB%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9
[11]: https://github.com/ts-stack/di
[12]: https://uk.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%B0%D0%BA_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%94%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F) "Singleton"